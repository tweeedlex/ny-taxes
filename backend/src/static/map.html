<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NY Tax Map</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    :root {
      --bg: #f3f5f7;
      --card: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --border: #cbd5e1;
      --accent: #0f766e;
      --warn: #b91c1c;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: var(--text);
      background: var(--bg);
    }

    main {
      width: min(96vw, 1760px);
      margin: 0 auto;
      padding: 16px;
      display: grid;
      gap: 12px;
    }

    .toolbar {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      align-items: end;
    }

    label {
      font-size: 13px;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    input {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      font: inherit;
      color: var(--text);
      background: #fff;
    }

    button {
      border: 1px solid #0f766e;
      border-radius: 8px;
      padding: 8px 12px;
      font: inherit;
      font-weight: 600;
      color: #ffffff;
      background: #0f766e;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .upload-row {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      display: flex;
      flex-wrap: wrap;
      align-items: end;
      gap: 10px;
    }

    .upload-row .spacer {
      flex: 1 1 200px;
      min-width: 200px;
    }

    .upload-status {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
    }

    .csv-progress-wrap {
      width: 100%;
      display: grid;
      gap: 8px;
    }

    .csv-progress-track {
      display: flex;
      width: 100%;
      height: 12px;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: #e5e7eb;
    }

    .csv-progress-segment {
      height: 100%;
      transition: width 140ms linear;
    }

    .csv-progress-success {
      background: #16a34a;
      width: 0%;
    }

    .csv-progress-pending {
      background: #9ca3af;
      width: 100%;
    }

    .csv-progress-failed {
      background: #dc2626;
      width: 0%;
    }

    .csv-progress-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 14px;
      font-size: 12px;
      color: #334155;
    }

    .tax-preview {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .tax-preview h2 {
      margin: 0;
      font-size: 16px;
    }

    .tax-metrics {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
    }

    .tax-metric {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: #fff;
    }

    .tax-metric-label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 3px;
    }

    .tax-metric-value {
      display: block;
      font-size: 17px;
      font-weight: 600;
      color: var(--accent);
    }

    .tax-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }

    .tax-block {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: #fff;
    }

    .tax-block h3 {
      margin: 0 0 8px;
      font-size: 14px;
    }

    .tax-rows {
      display: grid;
      gap: 6px;
    }

    .tax-row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 6px;
      background: #f8fafc;
      font-size: 13px;
    }

    .tax-row-label {
      color: var(--muted);
    }

    .tax-row-value {
      font-weight: 600;
    }

    .jurisdiction-list {
      display: grid;
      gap: 8px;
    }

    .jurisdiction-group {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #f8fafc;
      padding: 8px;
      display: grid;
      gap: 6px;
    }

    .jurisdiction-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #0f766e;
      font-weight: 700;
    }

    .jurisdiction-item {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      padding: 5px 6px;
      border-radius: 6px;
      background: #ffffff;
      font-size: 13px;
    }

    .jurisdiction-name {
      color: #111827;
    }

    .jurisdiction-rate {
      color: #0f766e;
      font-weight: 700;
    }

    .tax-error {
      color: var(--warn);
      font-size: 13px;
      margin-top: 4px;
    }

    details summary {
      cursor: pointer;
      font-size: 12px;
      color: var(--muted);
    }

    #map {
      height: 65vh;
      min-height: 480px;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
    }

    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
    }

    .panel h2 {
      margin: 0 0 8px;
      font-size: 16px;
    }

    .hint {
      margin: 0 0 8px;
      color: var(--muted);
      font-size: 13px;
    }

    pre {
      margin: 0;
      background: #0b1220;
      color: #d8e4ff;
      border-radius: 8px;
      padding: 12px;
      overflow: auto;
      max-height: 280px;
      font-size: 12px;
      line-height: 1.35;
    }

    .leaflet-tooltip.rate-only-tooltip {
      border-radius: 6px;
      color: #ffffff;
      font-size: 12px;
      font-weight: 700;
      padding: 3px 7px;
      box-shadow: none;
    }

    .leaflet-tooltip.rate-only-tooltip.rate-only-tooltip-pending {
      border: 1px solid #6b7280;
      background: #6b7280;
    }

    .leaflet-tooltip.rate-only-tooltip.rate-only-tooltip-success {
      border: 1px solid #0f766e;
      background: #0f766e;
    }

    .leaflet-tooltip.rate-only-tooltip.rate-only-tooltip-error {
      border: 1px solid #b91c1c;
      background: #b91c1c;
    }
  </style>
</head>
<body>
<main>
  <section class="toolbar">
    <label>
      Latitude
      <input id="latitude" type="number" step="any" placeholder="e.g. 42.4789958" />
    </label>
    <label>
      Longitude
      <input id="longitude" type="number" step="any" placeholder="e.g. -76.2653141" />
    </label>
    <label>
      Subtotal
      <input id="subtotal" type="number" step="0.01" min="0" value="100" placeholder="e.g. 120.00" />
    </label>
  </section>

  <section class="upload-row">
    <label>
      CSV file
      <input id="csvFile" type="file" accept=".csv,text/csv" />
    </label>
    <button id="csvProcessBtn" type="button">Preview CSV Points</button>
    <div class="spacer"></div>
    <p id="csvStatus" class="upload-status">Upload CSV to render tax-rate markers from file rows.</p>
    <div class="csv-progress-wrap">
      <div class="csv-progress-track">
        <div id="csvProgressSuccess" class="csv-progress-segment csv-progress-success"></div>
        <div id="csvProgressPending" class="csv-progress-segment csv-progress-pending"></div>
        <div id="csvProgressFailed" class="csv-progress-segment csv-progress-failed"></div>
      </div>
      <div class="csv-progress-meta">
        <span id="csvSuccessCount">Success: 0</span>
        <span id="csvPendingCount">Pending: 0</span>
        <span id="csvFailedCount">Errors: 0</span>
      </div>
    </div>
  </section>

  <section class="tax-preview">
    <h2>Tax Preview</h2>
    <p class="hint">
      Click the map or edit latitude/longitude. Subtotal is editable, timestamp is current time.
    </p>

    <div class="tax-metrics">
      <div class="tax-metric">
        <span class="tax-metric-label">Reporting code</span>
        <span id="taxReportingCode" class="tax-metric-value">-</span>
      </div>
      <div class="tax-metric">
        <span class="tax-metric-label">Composite tax rate</span>
        <span id="taxCompositeRate" class="tax-metric-value">-</span>
      </div>
      <div class="tax-metric">
        <span class="tax-metric-label">Tax amount</span>
        <span id="taxAmount" class="tax-metric-value">-</span>
      </div>
      <div class="tax-metric">
        <span class="tax-metric-label">Total amount</span>
        <span id="taxTotalAmount" class="tax-metric-value">-</span>
      </div>
    </div>

    <div class="tax-grid">
      <div class="tax-block">
        <h3>Breakdown</h3>
        <div id="taxBreakdown" class="tax-rows"></div>
      </div>
      <div class="tax-block">
        <h3>Jurisdictions</h3>
        <div id="taxJurisdictions" class="tax-rows"></div>
      </div>
    </div>

    <div id="taxError" class="tax-error"></div>
  </section>

  <div id="map"></div>
</main>

<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>
<script src="https://unpkg.com/proj4@2.11.0/dist/proj4.js"></script>
<script src="https://unpkg.com/shpjs@latest/dist/shp.min.js"></script>
<script>
  const latInput = document.getElementById("latitude");
  const lonInput = document.getElementById("longitude");
  const subtotalInput = document.getElementById("subtotal");
  const csvFileInput = document.getElementById("csvFile");
  const csvProcessBtn = document.getElementById("csvProcessBtn");
  const csvStatus = document.getElementById("csvStatus");
  const csvProgressSuccess = document.getElementById("csvProgressSuccess");
  const csvProgressPending = document.getElementById("csvProgressPending");
  const csvProgressFailed = document.getElementById("csvProgressFailed");
  const csvSuccessCount = document.getElementById("csvSuccessCount");
  const csvPendingCount = document.getElementById("csvPendingCount");
  const csvFailedCount = document.getElementById("csvFailedCount");
  const taxError = document.getElementById("taxError");
  const taxReportingCode = document.getElementById("taxReportingCode");
  const taxCompositeRate = document.getElementById("taxCompositeRate");
  const taxAmount = document.getElementById("taxAmount");
  const taxTotalAmount = document.getElementById("taxTotalAmount");
  const taxBreakdown = document.getElementById("taxBreakdown");
  const taxJurisdictions = document.getElementById("taxJurisdictions");
  const RATE_SECTION_KEYS = ["state_rate", "county_rate", "city_rate", "special_rates"];
  const MIN_SUPPORTED_DATE_UTC = Date.UTC(2025, 2, 1);
  const DEFAULT_PREVIEW_SUBTOTAL = 100;
  const CSV_PREVIEW_SUBTOTAL = 100;

  if (!window.L || !window.proj4 || !window.shp) {
    taxError.textContent = "Map dependencies failed to load (Leaflet/proj4/shpjs).";
    updatePrettyPreview({
      ok: false,
      error: {
        code: "dependencies_failed",
        detail: "Failed to initialize map dependencies. Check network access to unpkg.com or use local JS assets.",
      },
    });
  } else {
  proj4.defs(
    "EPSG:26918",
    "+proj=utm +zone=18 +datum=NAD83 +units=m +no_defs +type=crs"
  );

  const map = L.map("map", { preferCanvas: true }).setView([42.95, -75.6], 7);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap contributors",
  }).addTo(map);

  let clickMarker = null;
  const importMarkersLayer = L.layerGroup().addTo(map);
  let taxEngineReady = false;
  let importRunning = false;
  let importQueue = [];
  let importStats = null;
  let cityRegions = [];
  let countyRegions = [];
  let ratesByReportingCode = null;

  function setCsvProgress(success, pending, failed, total) {
    const normalizedTotal = Math.max(Number(total) || 0, 0);
    const denominator = Math.max(normalizedTotal, 1);

    const successWidth = normalizedTotal === 0 ? 0 : (Math.max(success, 0) / denominator) * 100;
    const pendingWidth = normalizedTotal === 0 ? 100 : (Math.max(pending, 0) / denominator) * 100;
    const failedWidth = normalizedTotal === 0 ? 0 : (Math.max(failed, 0) / denominator) * 100;

    csvProgressSuccess.style.width = `${successWidth}%`;
    csvProgressPending.style.width = `${pendingWidth}%`;
    csvProgressFailed.style.width = `${failedWidth}%`;

    csvSuccessCount.textContent = `Success: ${Math.max(success, 0)}`;
    csvPendingCount.textContent = `Pending: ${Math.max(pending, 0)}`;
    csvFailedCount.textContent = `Errors: ${Math.max(failed, 0)}`;
  }

  function resetCsvProgress() {
    setCsvProgress(0, 0, 0, 0);
  }

  function formatMoney(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return "-";
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(num);
  }

  function formatRate(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return "-";
    return `${(num * 100).toFixed(3).replace(/\.?0+$/, "")}%`;
  }

  function formatRateForMarker(value) {
    const formatted = formatRate(value);
    return formatted.replace(".", ",");
  }

  function setCsvStatus(text) {
    csvStatus.textContent = text;
  }

  function updateCsvStatus() {
    if (!importStats) {
      resetCsvProgress();
      return;
    }

    const pending = Math.max(importStats.total - importStats.success - importStats.failed, 0);
    setCsvProgress(importStats.success, pending, importStats.failed, importStats.total);

    if (pending > 0) {
      setCsvStatus(
        `Processing ${importStats.done}/${importStats.total} rows` +
          ` (ok: ${importStats.success}, errors: ${importStats.failed}).`
      );
      return;
    }
    setCsvStatus(
      `Completed ${importStats.total} rows` +
        ` (ok: ${importStats.success}, errors: ${importStats.failed}).`
    );
    csvProcessBtn.disabled = false;
  }

  function normalizeHeaderKey(rawValue) {
    return String(rawValue || "")
      .trim()
      .toLowerCase()
      .replaceAll("_", "")
      .replaceAll(" ", "");
  }

  function parseCsvLine(line) {
    const result = [];
    let current = "";
    let inQuotes = false;
    for (let idx = 0; idx < line.length; idx += 1) {
      const char = line[idx];
      if (char === '"') {
        if (inQuotes && idx + 1 < line.length && line[idx + 1] === '"') {
          current += '"';
          idx += 1;
        } else {
          inQuotes = !inQuotes;
        }
        continue;
      }
      if (char === "," && !inQuotes) {
        result.push(current);
        current = "";
        continue;
      }
      current += char;
    }
    result.push(current);
    return result;
  }

  function extractCsvCell(cells, index) {
    if (index < 0 || index >= cells.length) return "";
    return String(cells[index] || "").trim();
  }

  function parseImportCsv(text) {
    const normalizedText = String(text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    const lines = normalizedText.split("\n");
    let headerLineIndex = -1;
    let headers = [];
    for (let idx = 0; idx < lines.length; idx += 1) {
      if (!lines[idx].trim()) continue;
      headerLineIndex = idx;
      headers = parseCsvLine(lines[idx]);
      break;
    }

    if (headerLineIndex === -1 || !headers.length) {
      throw new Error("CSV file is empty or has no header.");
    }

    const indexesByKey = {};
    headers.forEach((header, index) => {
      const key = normalizeHeaderKey(header);
      if (key) indexesByKey[key] = index;
    });

    const requiredKeys = ["longitude", "latitude", "timestamp", "subtotal"];
    const missing = requiredKeys.filter((key) => !(key in indexesByKey));
    if (missing.length) {
      throw new Error(`Missing required CSV columns: ${missing.join(", ")}`);
    }

    const rows = [];
    let totalRows = 0;
    let skipped = 0;
    for (let idx = headerLineIndex + 1; idx < lines.length; idx += 1) {
      const rawLine = lines[idx];
      if (!rawLine.trim()) continue;
      totalRows += 1;

      const cells = parseCsvLine(rawLine);
      const longitudeRaw = extractCsvCell(cells, indexesByKey.longitude);
      const latitudeRaw = extractCsvCell(cells, indexesByKey.latitude);
      const timestampRaw = extractCsvCell(cells, indexesByKey.timestamp);
      const subtotalRaw = extractCsvCell(cells, indexesByKey.subtotal);
      if (!longitudeRaw || !latitudeRaw || !timestampRaw || !subtotalRaw) {
        skipped += 1;
        continue;
      }

      const longitude = Number(longitudeRaw);
      const latitude = Number(latitudeRaw);
      if (!Number.isFinite(latitude) || !Number.isFinite(longitude)) {
        skipped += 1;
        continue;
      }
      if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) {
        skipped += 1;
        continue;
      }

      rows.push({ latitude, longitude });
    }

    return { rows, skipped, totalRows };
  }

  function createImportMarker(lat, lon) {
    const marker = L.circleMarker([lat, lon], {
      radius: 6,
      color: "#ffffff",
      weight: 1.5,
      fillColor: "#64748b",
      fillOpacity: 0.9,
    }).addTo(importMarkersLayer);
    bindRateOnlyTooltip(marker, "...", "pending");
    return marker;
  }

  function bindRateOnlyTooltip(marker, text, variant) {
    const classSuffix = variant === "error"
      ? "rate-only-tooltip-error"
      : variant === "pending"
        ? "rate-only-tooltip-pending"
        : "rate-only-tooltip-success";
    marker.unbindTooltip();
    marker.bindTooltip(text, {
      direction: "top",
      offset: [0, -8],
      className: `rate-only-tooltip ${classSuffix}`,
    });
  }

  function updateImportMarkerSuccess(marker, compositeTaxRate) {
    marker.setStyle({
      fillColor: "#0f766e",
      color: "#ffffff",
      weight: 1.5,
    });
    bindRateOnlyTooltip(marker, formatRateForMarker(compositeTaxRate), "success");
  }

  function updateImportMarkerFailure(marker) {
    marker.setStyle({
      fillColor: "#b91c1c",
      color: "#ffffff",
      weight: 1.5,
    });
    bindRateOnlyTooltip(marker, "N/A", "error");
  }

  function renderRows(container, rows) {
    container.innerHTML = "";
    if (!rows.length) {
      const empty = document.createElement("div");
      empty.className = "tax-row";
      empty.innerHTML = '<span class="tax-row-label">No data</span><span class="tax-row-value">-</span>';
      container.appendChild(empty);
      return;
    }
    for (const row of rows) {
      const rowEl = document.createElement("div");
      rowEl.className = "tax-row";
      const labelEl = document.createElement("span");
      labelEl.className = "tax-row-label";
      labelEl.textContent = row.label;
      const valueEl = document.createElement("span");
      valueEl.className = "tax-row-value";
      valueEl.textContent = row.value;
      rowEl.appendChild(labelEl);
      rowEl.appendChild(valueEl);
      container.appendChild(rowEl);
    }
  }

  function resetPrettyPreview() {
    taxReportingCode.textContent = "-";
    taxCompositeRate.textContent = "-";
    taxAmount.textContent = "-";
    taxTotalAmount.textContent = "-";
    renderRows(taxBreakdown, []);
    taxJurisdictions.innerHTML = "";
  }

  function renderJurisdictions(jurisdictions) {
    const labels = {
      state_rate: "State Jurisdiction",
      county_rate: "County Jurisdiction",
      city_rate: "City Jurisdiction",
      special_rates: "Special Jurisdiction",
    };
    const orderedKeys = ["state_rate", "county_rate", "city_rate", "special_rates"];

    taxJurisdictions.innerHTML = "";
    const wrapper = document.createElement("div");
    wrapper.className = "jurisdiction-list";

    let hasAny = false;
    for (const key of orderedKeys) {
      const items = Array.isArray(jurisdictions[key]) ? jurisdictions[key] : [];
      if (!items.length) continue;
      hasAny = true;

      const group = document.createElement("div");
      group.className = "jurisdiction-group";

      const title = document.createElement("div");
      title.className = "jurisdiction-title";
      title.textContent = labels[key] || key;
      group.appendChild(title);

      for (const item of items) {
        const row = document.createElement("div");
        row.className = "jurisdiction-item";

        const name = document.createElement("span");
        name.className = "jurisdiction-name";
        name.textContent = item && item.name ? item.name : "-";

        const rate = document.createElement("span");
        rate.className = "jurisdiction-rate";
        rate.textContent = formatRate(item && item.rate);

        row.appendChild(name);
        row.appendChild(rate);
        group.appendChild(row);
      }

      wrapper.appendChild(group);
    }

    if (!hasAny) {
      const empty = document.createElement("div");
      empty.className = "tax-row";
      empty.innerHTML = '<span class="tax-row-label">No jurisdictions applied</span><span class="tax-row-value">-</span>';
      taxJurisdictions.appendChild(empty);
      return;
    }

    taxJurisdictions.appendChild(wrapper);
  }

  function updatePrettyPreview(data) {
    taxError.textContent = "";
    if (!data || data.ok !== true || !data.result) {
      resetPrettyPreview();
      if (data && data.error && data.error.detail) {
        taxError.textContent = data.error.detail;
      }
      return;
    }

    const result = data.result;
    taxReportingCode.textContent = result.reporting_code || "-";
    taxCompositeRate.textContent = formatRate(result.composite_tax_rate);
    taxAmount.textContent = formatMoney(result.tax_amount);
    taxTotalAmount.textContent = formatMoney(result.total_amount);

    const breakdown = result.breakdown || {};
    renderRows(taxBreakdown, [
      { label: "State rate", value: formatRate(breakdown.state_rate) },
      { label: "County rate", value: formatRate(breakdown.county_rate) },
      { label: "City rate", value: formatRate(breakdown.city_rate) },
      { label: "Special rates", value: formatRate(breakdown.special_rates) },
    ]);

    const jurisdictions = result.jurisdictions || {};
    renderJurisdictions(jurisdictions);
  }

  function normalizeFeatureCollections(raw) {
    if (!raw) return [];
    if (raw.type === "FeatureCollection") return [raw];
    if (Array.isArray(raw)) {
      return raw.filter((entry) => entry && entry.type === "FeatureCollection");
    }
    if (typeof raw === "object") {
      return Object.values(raw).filter(
        (entry) => entry && entry.type === "FeatureCollection"
      );
    }
    return [];
  }

  function transformCoordinates(coords, converter) {
    if (!Array.isArray(coords)) return coords;
    if (coords.length === 0) return coords;
    if (typeof coords[0] === "number" && typeof coords[1] === "number") {
      return converter(coords);
    }
    return coords.map((child) => transformCoordinates(child, converter));
  }

  function convertGeoJsonToWgs84IfNeeded(featureCollection) {
    let needsProjection = false;

    for (const feature of featureCollection.features || []) {
      const geometry = feature && feature.geometry;
      if (!geometry || !Array.isArray(geometry.coordinates)) continue;

      const queue = [geometry.coordinates];
      while (queue.length > 0) {
        const item = queue.pop();
        if (!Array.isArray(item) || item.length === 0) continue;
        if (typeof item[0] === "number" && typeof item[1] === "number") {
          const x = item[0];
          const y = item[1];
          if (Math.abs(x) > 180 || Math.abs(y) > 90) {
            needsProjection = true;
          }
          break;
        }
        for (const nested of item) queue.push(nested);
      }
      if (needsProjection) break;
    }

    if (!needsProjection) return featureCollection;

    return {
      ...featureCollection,
      features: (featureCollection.features || []).map((feature) => {
        const geometry = feature && feature.geometry;
        if (!geometry || !Array.isArray(geometry.coordinates)) return feature;
        return {
          ...feature,
          geometry: {
            ...geometry,
            coordinates: transformCoordinates(geometry.coordinates, (coord) => {
              const wgs84 = proj4("EPSG:26918", "EPSG:4326", coord);
              return [wgs84[0], wgs84[1]];
            }),
          },
        };
      }),
    };
  }

  function normalizeReportingCode(rawReportingCode) {
    const value = String(rawReportingCode || "").trim();
    if (!value) return "";
    if (/^\d+$/.test(value) && value.length <= 4) {
      return value.padStart(4, "0");
    }
    return value;
  }

  function extractPolygonsFromGeometry(geometry) {
    if (!geometry || !Array.isArray(geometry.coordinates)) return [];
    if (geometry.type === "Polygon") return [geometry.coordinates];
    if (geometry.type === "MultiPolygon") return geometry.coordinates;
    return [];
  }

  function computePolygonBBox(polygons) {
    let minLon = Infinity;
    let minLat = Infinity;
    let maxLon = -Infinity;
    let maxLat = -Infinity;
    for (const polygon of polygons) {
      for (const ring of polygon) {
        for (const coord of ring) {
          if (!Array.isArray(coord) || coord.length < 2) continue;
          const lon = Number(coord[0]);
          const lat = Number(coord[1]);
          if (!Number.isFinite(lon) || !Number.isFinite(lat)) continue;
          if (lon < minLon) minLon = lon;
          if (lon > maxLon) maxLon = lon;
          if (lat < minLat) minLat = lat;
          if (lat > maxLat) maxLat = lat;
        }
      }
    }
    if (!Number.isFinite(minLon)) return null;
    return [minLon, minLat, maxLon, maxLat];
  }

  function buildRegionsFromCollections(collections) {
    const regions = [];
    for (const collection of collections) {
      for (const feature of collection.features || []) {
        const codeRaw =
          feature && feature.properties ? feature.properties.REP_CODE ?? feature.properties.reporting_code : null;
        const reportingCode = normalizeReportingCode(codeRaw);
        if (!reportingCode) continue;

        const polygons = extractPolygonsFromGeometry(feature && feature.geometry);
        if (!polygons.length) continue;
        const bbox = computePolygonBBox(polygons);
        if (!bbox) continue;
        regions.push({ reportingCode, polygons, bbox });
      }
    }
    return regions;
  }

  function pointOnSegment(px, py, x1, y1, x2, y2) {
    const eps = 1e-12;
    const cross = (py - y1) * (x2 - x1) - (px - x1) * (y2 - y1);
    if (Math.abs(cross) > eps) return false;
    const minX = Math.min(x1, x2);
    const maxX = Math.max(x1, x2);
    const minY = Math.min(y1, y2);
    const maxY = Math.max(y1, y2);
    return px >= minX - eps && px <= maxX + eps && py >= minY - eps && py <= maxY + eps;
  }

  function pointInRing(lon, lat, ring) {
    if (!Array.isArray(ring) || ring.length < 3) return false;
    let inside = false;
    let prevLon = Number(ring[ring.length - 1][0]);
    let prevLat = Number(ring[ring.length - 1][1]);
    for (const coord of ring) {
      const currLon = Number(coord[0]);
      const currLat = Number(coord[1]);
      if (!Number.isFinite(currLon) || !Number.isFinite(currLat)) {
        prevLon = currLon;
        prevLat = currLat;
        continue;
      }

      if (pointOnSegment(lon, lat, prevLon, prevLat, currLon, currLat)) {
        return true;
      }

      if ((currLat > lat) !== (prevLat > lat)) {
        const lonIntersection =
          ((prevLon - currLon) * (lat - currLat)) / (prevLat - currLat) + currLon;
        if (lon < lonIntersection) {
          inside = !inside;
        }
      }
      prevLon = currLon;
      prevLat = currLat;
    }
    return inside;
  }

  function pointInRegion(lon, lat, region) {
    const [minLon, minLat, maxLon, maxLat] = region.bbox;
    if (!(minLon <= lon && lon <= maxLon && minLat <= lat && lat <= maxLat)) {
      return false;
    }
    let inside = false;
    for (const polygon of region.polygons) {
      for (const ring of polygon) {
        if (pointInRing(lon, lat, ring)) {
          inside = !inside;
        }
      }
    }
    return inside;
  }

  function findReportingCodeInRegions(lat, lon, regions) {
    for (const region of regions) {
      if (pointInRegion(lon, lat, region)) {
        return region.reportingCode;
      }
    }
    return null;
  }

  function validateCoordinates(lat, lon) {
    if (!Number.isFinite(lat) || lat < -90 || lat > 90) {
      throw new Error("Latitude must be between -90 and 90.");
    }
    if (!Number.isFinite(lon) || lon < -180 || lon > 180) {
      throw new Error("Longitude must be between -180 and 180.");
    }
  }

  function validateTimestamp(timestampRaw) {
    const parsed = new Date(timestampRaw);
    if (Number.isNaN(parsed.getTime())) {
      throw new Error("timestamp must be a valid ISO datetime.");
    }
    const parsedDateUtc = Date.UTC(
      parsed.getUTCFullYear(),
      parsed.getUTCMonth(),
      parsed.getUTCDate()
    );
    if (parsedDateUtc < MIN_SUPPORTED_DATE_UTC) {
      throw new Error("timestamp cannot be earlier than 2025-03-01");
    }
  }

  function sumRates(items) {
    return items.reduce((acc, item) => acc + Number(item.rate || 0), 0);
  }

  function roundHalfUp(value, scale) {
    const factor = 10 ** scale;
    return Math.round((Number(value) + Number.EPSILON) * factor) / factor;
  }

  function normalizeSubtotal(subtotalRaw) {
    const value = Number(subtotalRaw);
    if (!Number.isFinite(value) || value < 0) {
      throw new Error("subtotal must be >= 0");
    }
    return roundHalfUp(value, 2);
  }

  function parseRatesSection(section, code, sectionName) {
    if (!Array.isArray(section)) {
      throw new Error(`Tax payload section '${sectionName}' must be an array for reporting_code=${code}.`);
    }
    return section.map((item, idx) => {
      if (!item || typeof item !== "object") {
        throw new Error(`Item ${idx} in '${sectionName}' must be an object for reporting_code=${code}.`);
      }
      const name = String(item.name || "").trim();
      const rate = Number(item.rate);
      if (!name || !Number.isFinite(rate)) {
        throw new Error(
          `Item ${idx} in '${sectionName}' must include valid 'name' and 'rate' for reporting_code=${code}.`
        );
      }
      return { name, rate };
    });
  }

  function parseTaxRatesPayload(raw) {
    if (!raw || typeof raw !== "object" || Array.isArray(raw)) {
      throw new Error("Tax rates JSON root must be an object.");
    }
    const result = new Map();
    for (const [rawCode, rawPayload] of Object.entries(raw)) {
      const code = normalizeReportingCode(rawCode);
      if (!code) continue;
      if (!rawPayload || typeof rawPayload !== "object" || Array.isArray(rawPayload)) {
        throw new Error(`Invalid tax payload for reporting_code=${code}.`);
      }
      const missing = RATE_SECTION_KEYS.filter((key) => !(key in rawPayload));
      if (missing.length) {
        throw new Error(`Missing sections ${missing.join(", ")} for reporting_code=${code}.`);
      }
      const unknown = Object.keys(rawPayload).filter((key) => !RATE_SECTION_KEYS.includes(key));
      if (unknown.length) {
        throw new Error(`Unknown sections ${unknown.join(", ")} for reporting_code=${code}.`);
      }

      result.set(code, {
        state_rate: parseRatesSection(rawPayload.state_rate, code, "state_rate"),
        county_rate: parseRatesSection(rawPayload.county_rate, code, "county_rate"),
        city_rate: parseRatesSection(rawPayload.city_rate, code, "city_rate"),
        special_rates: parseRatesSection(rawPayload.special_rates, code, "special_rates"),
      });
    }
    return result;
  }

  async function loadTaxRates() {
    const ratesUrl = new URL("./ny_tax_rates.json", window.location.href).href;
    const response = await fetch(ratesUrl, { cache: "no-store" });
    if (!response.ok) {
      throw new Error(`Failed to load tax rates: HTTP ${response.status}`);
    }
    const raw = await response.json();
    ratesByReportingCode = parseTaxRatesPayload(raw);
  }

  function findReportingCodeByCoordinates(lat, lon) {
    const cityCode = findReportingCodeInRegions(lat, lon, cityRegions);
    if (cityCode) return cityCode;
    const countyCode = findReportingCodeInRegions(lat, lon, countyRegions);
    if (countyCode) return countyCode;
    return null;
  }

  function calculateTaxPreviewLocally(payload) {
    try {
      validateCoordinates(payload.latitude, payload.longitude);
      validateTimestamp(payload.timestamp);
      const subtotal = normalizeSubtotal(payload.subtotal);

      const reportingCode = findReportingCodeByCoordinates(payload.latitude, payload.longitude);
      if (!reportingCode) {
        throw new Error("Delivery point is outside New York State coverage.");
      }

      const jurisdictions = ratesByReportingCode.get(normalizeReportingCode(reportingCode));
      if (!jurisdictions) {
        throw new Error(`Tax rate not found for reporting code ${reportingCode}.`);
      }

      const stateRate = roundHalfUp(sumRates(jurisdictions.state_rate), 5);
      const countyRate = roundHalfUp(sumRates(jurisdictions.county_rate), 5);
      const cityRate = roundHalfUp(sumRates(jurisdictions.city_rate), 5);
      const specialRates = roundHalfUp(sumRates(jurisdictions.special_rates), 5);
      const compositeTaxRate = roundHalfUp(stateRate + countyRate + cityRate + specialRates, 5);
      const taxAmount = roundHalfUp(subtotal * compositeTaxRate, 2);
      const totalAmount = roundHalfUp(subtotal + taxAmount, 2);

      return {
        ok: true,
        result: {
          reporting_code: normalizeReportingCode(reportingCode),
          jurisdictions,
          composite_tax_rate: compositeTaxRate,
          tax_amount: taxAmount,
          total_amount: totalAmount,
          breakdown: {
            state_rate: stateRate,
            county_rate: countyRate,
            city_rate: cityRate,
            special_rates: specialRates,
          },
        },
      };
    } catch (error) {
      const detail = error instanceof Error ? error.message : "Unexpected local calculation error.";
      let code = "validation_error";
      if (detail.includes("outside New York State coverage")) {
        code = "outside_coverage";
      } else if (detail.includes("Tax rate not found")) {
        code = "tax_rate_not_found";
      }
      return {
        ok: false,
        error: { code, detail },
      };
    }
  }

  async function loadShapefileLayer(baseName, style) {
    const shpUrl = new URL(`./shapefiles/${baseName}.shp`, window.location.href).href;
    const raw = await shp(shpUrl);
    const collections = normalizeFeatureCollections(raw).map(convertGeoJsonToWgs84IfNeeded);
    const allLayers = [];
    for (const collection of collections) {
      const layer = L.geoJSON(collection, { style }).addTo(map);
      allLayers.push(layer);
    }
    return {
      layers: allLayers,
      regions: buildRegionsFromCollections(collections),
    };
  }

  async function loadBoundaryLayers() {
    const [countiesLayer, citiesLayer] = await Promise.all([
      loadShapefileLayer("Counties", {
        color: "#1d4ed8",
        weight: 1.3,
        fillColor: "#93c5fd",
        fillOpacity: 0.08,
      }),
      loadShapefileLayer("Cities", {
        color: "#ea580c",
        weight: 1,
        fillColor: "#fdba74",
        fillOpacity: 0.2,
      }),
    ]);

    countyRegions = countiesLayer.regions;
    cityRegions = citiesLayer.regions;

    const bounds = L.latLngBounds([]);
    const layerGroups = [countiesLayer.layers, citiesLayer.layers];
    for (const group of layerGroups) {
      for (const layer of group) {
        if (layer.getBounds && layer.getBounds().isValid()) {
          bounds.extend(layer.getBounds());
        }
      }
    }
    if (bounds.isValid()) {
      map.fitBounds(bounds, { padding: [20, 20] });
    }
  }

  function setMarker(lat, lon) {
    const latLng = [lat, lon];
    if (clickMarker) {
      clickMarker.setLatLng(latLng);
      return;
    }
    clickMarker = L.circleMarker(latLng, {
      radius: 7,
      color: "#ffffff",
      weight: 2,
      fillColor: "#e11d48",
      fillOpacity: 0.95,
    }).addTo(map);
  }

  function buildPayload(lat, lon, subtotalOverride = null) {
    const subtotalRaw =
      subtotalOverride === null ? parseInputNumber(subtotalInput) : Number(subtotalOverride);
    const subtotal = Number.isFinite(subtotalRaw) && subtotalRaw >= 0
      ? Number(subtotalRaw.toFixed(2))
      : DEFAULT_PREVIEW_SUBTOTAL;
    return {
      latitude: lat,
      longitude: lon,
      subtotal,
      timestamp: new Date().toISOString(),
    };
  }

  function isImportProcessing() {
    return importRunning || importQueue.length > 0;
  }

  async function processImportQueueLocally() {
    if (!importStats || !importQueue.length) {
      updateCsvStatus();
      return;
    }
    importRunning = true;
    updateCsvStatus();

    while (importQueue.length) {
      const request = importQueue.shift();
      const result = calculateTaxPreviewLocally(request.payload);
      importStats.done += 1;

      if (result && result.ok === true && result.result) {
        updateImportMarkerSuccess(request.marker, result.result.composite_tax_rate);
        importStats.success += 1;
      } else {
        updateImportMarkerFailure(request.marker);
        importStats.failed += 1;
      }

      if (importStats.done % 100 === 0) {
        updateCsvStatus();
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
    }

    importRunning = false;
    updateCsvStatus();
  }

  async function processCsvFileForMarkers() {
    if (!taxEngineReady) {
      setCsvStatus("Local tax engine is not ready yet.");
      return;
    }

    const file = csvFileInput.files && csvFileInput.files[0];
    if (!file) {
      setCsvStatus("Select a CSV file first.");
      return;
    }

    let text = "";
    try {
      text = await file.text();
    } catch (_) {
      setCsvStatus("Failed to read file.");
      return;
    }

    let parsed;
    try {
      parsed = parseImportCsv(text);
    } catch (error) {
      setCsvStatus(String(error));
      return;
    }

    importMarkersLayer.clearLayers();
    importQueue = [];
    importRunning = false;

    const bounds = L.latLngBounds([]);
    for (const row of parsed.rows) {
      const marker = createImportMarker(row.latitude, row.longitude);
      importQueue.push({
        marker,
        payload: buildPayload(row.latitude, row.longitude, CSV_PREVIEW_SUBTOTAL),
      });
      bounds.extend([row.latitude, row.longitude]);
    }

    importStats = {
      total: parsed.totalRows,
      done: parsed.skipped,
      success: 0,
      failed: parsed.skipped,
    };

    if (parsed.totalRows === 0) {
      setCsvStatus("No data rows found in CSV.");
      resetCsvProgress();
      csvProcessBtn.disabled = false;
      return;
    }

    csvProcessBtn.disabled = true;
    updateCsvStatus();
    if (bounds.isValid()) {
      map.fitBounds(bounds, { padding: [20, 20] });
    }

    if (!importQueue.length) {
      updateCsvStatus();
      return;
    }

    await processImportQueueLocally();
  }

  function sendTaxPreview(lat, lon) {
    if (isImportProcessing()) {
      taxError.textContent = "CSV processing is running. Wait until it completes.";
      return;
    }

    if (!taxEngineReady) {
      const waitingPayload = {
        ok: false,
        error: {
          code: "engine_not_ready",
          detail: "Local tax engine is still initializing.",
        },
      };
      updatePrettyPreview(waitingPayload);
      return;
    }

    const payload = buildPayload(lat, lon);
    const result = calculateTaxPreviewLocally(payload);
    updatePrettyPreview(result);
  }

  function handleCoordinates(lat, lon, shouldCenter) {
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return;

    setMarker(lat, lon);
    if (shouldCenter) {
      map.panTo([lat, lon], { animate: true });
    }
    sendTaxPreview(lat, lon);
  }

  function parseInputNumber(input) {
    const value = input.value.trim();
    if (!value) return null;
    const num = Number(value);
    return Number.isFinite(num) ? num : null;
  }

  function debounce(fn, delayMs) {
    let timer = null;
    return (...args) => {
      if (timer) clearTimeout(timer);
      timer = setTimeout(() => fn(...args), delayMs);
    };
  }

  async function initializeLocalTaxEngine() {
    taxEngineReady = false;
    setCsvStatus("Initializing local tax engine...");
    try {
      await Promise.all([loadBoundaryLayers(), loadTaxRates()]);
      taxEngineReady = true;
      setCsvStatus("Local tax engine is ready. Upload CSV or pick a point on map.");
      taxError.textContent = "";
    } catch (error) {
      taxEngineReady = false;
      const payload = {
        ok: false,
        error: {
          code: "engine_init_failed",
          detail: String(error),
        },
      };
      updatePrettyPreview(payload);
      setCsvStatus("Failed to initialize local tax engine.");
    }
  }

  const onInputChanged = debounce(() => {
    const lat = parseInputNumber(latInput);
    const lon = parseInputNumber(lonInput);
    if (lat === null || lon === null) return;
    handleCoordinates(lat, lon, true);
  }, 250);

  latInput.addEventListener("input", onInputChanged);
  lonInput.addEventListener("input", onInputChanged);
  subtotalInput.addEventListener("input", onInputChanged);
  csvProcessBtn.addEventListener("click", () => {
    csvProcessBtn.disabled = true;
    processCsvFileForMarkers()
      .catch(() => {
        setCsvStatus("Unexpected error while processing CSV.");
      })
      .finally(() => {
        if (!isImportProcessing()) {
          csvProcessBtn.disabled = false;
        }
      });
  });
  csvFileInput.addEventListener("change", () => {
    setCsvStatus("File selected. Click \"Preview CSV Points\" to process rows.");
  });

  map.on("click", (event) => {
    const lat = Number(event.latlng.lat.toFixed(8));
    const lon = Number(event.latlng.lng.toFixed(8));
    latInput.value = String(lat);
    lonInput.value = String(lon);
    handleCoordinates(lat, lon, false);
  });

  resetPrettyPreview();
  initializeLocalTaxEngine();
  }
</script>
</body>
</html>
